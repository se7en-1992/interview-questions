# 浏览器合成层

1. 当DOM树构建成Render树后 会生成LayoutObject，基于同层级的LayoutObject会生成RenderLayers（渲染层）
2. 在生成RenderLayers（渲染层）的过程中某些特殊的RenderLayers（渲染层）会形成合成层，会单独拥有一个GraphicsLayer（图形层）
3. GraphicsLaye（图形层）作为纹理(从主存储器(例如 RAM)移动到图像存储器(例如 GPU 中的 VRAM)的位图图像(bitmapimage))上传给GPU的。

- 如何变成合成层
    - will-change、filters、transform、opacity等
    - 3D 或透视变换(perspective transform) CSS 属性
    - 使用加速视频解码的 <video> 元素 拥有 3D
    - (WebGL) 上下文或加速的 2D 上下文的 <canvas> 元素
    - 混合插件(如 Flash)
    - 对自己的 opacity 做 CSS动画或使用一个动画变换的元素
    - 拥有加速 CSS 过滤器的元素
    - 元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
    - 元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

# 浏览器跨域
1. 同源策略导致浏览器跨域
2. cors跨域原理  发送预请求`options`请求，服务端返回`allow-orgin`, `allow-methods`等字段
3. cors的简单请求不会发送预请求`options`请求，复杂请求才会发送预请求

# 浏览器渲染进程

构建DOM树 => 
                合并构建render树 => layout => paint => Compositing
构建CSSOM树 => 

1. 遇到无`aysnc`和`defer`的`script`浏览器会阻塞html渲染
2. 预加载扫描器优先级

- GUI渲染线程

负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。

- JS引擎线程

也称为JS内核，负责解析Javascript脚本，运行代码。（例如V8引擎）

JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个渲染进程中无论什么时候都有一个JS线程在运行JS程序。

需要注意的是：
GUI渲染线程与JS引擎线程是相互排斥的。因为JS引擎线程在执行的过程中可能会发生回流和重绘，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后。同理，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存起来等到JS引擎空闲时立即被执行。所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染阻塞


# 浏览器缓存

- 强缓存

根据请求头的expires和cache-control判断是否命中强缓存

- 协商缓存

# preload和prefetch的区别

preload 告诉浏览器立即加载资源;
prefetch 告诉浏览器在空闲时才开始加载资源；
preload、prefetch 仅仅是加载资源，并不会“执行”;
preload、prefetch 均能设置、命中缓存；
正确使用 preload、prefetch 不会导致重复请求；

1、preload和prefetch的本质都是预加载，即先加载、后执行，加载与执行解耦。
2、preload和prefetch不会阻塞页面的onload。
3、preload用来声明当前页面的关键资源，强制浏览器尽快加载；而prefetch用来声明将来可能用到的资源，在浏览器空闲时进行加载。
4、不要滥用preload和prefetch，需要在合适的场景中使用。
5、preload的字体资源必须设置crossorigin属性，否则会导致重复加载。
原因是如果不指定crossorigin属性(即使同源)，浏览器会采用匿名模式的CORS去preload，导致两次请求无法共用缓存。
6、关于preload和prefetch资源的缓存，在Google开发者的一篇文章中是这样说明的：如果资源可以被缓存（比如说存在有效的cache-control和max-age），它被存储在HTTP缓存（也就是disk cache)中，可以被现在或将来的任务使用；如果资源不能被缓存在HTTP缓存中，作为代替，它被放在内存缓存中直到被使用。
然而我们在Chrome浏览器（版本号80）中进行测试，结果却并非如此。将服务器的缓存策略设置为no-store，观察下资源加载情况。


# 现代浏览器的线程架构
1. 浏览器主线程

负责界面显示、用户交互、子进程管理，同时提供存储等功能。

2. 渲染线程

核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。
排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中。
默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。
出于安全考虑，渲染进程都是运行在沙箱模式下，无法访问系统资源。

3. GPU线程

Chrome 刚开始发布的时候是没有 GPU 进程的。
GPU 的使用初衷是为了实现 3D CSS 的效果。
随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。
最后，Chrome 在其多进程架构上也引入了 GPU 进程

4. 网络线程

主要负责页面的网络资源加载。
之前是作为一个模块运行在浏览器主进程里面的，直至最近才独立出来，成为一个单独的进程。

5. 插件线程

主要是负责插件的运行。
因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。


### 关于css样式和脚本问题
1. 为什么网页中经常把 css 文件添加在 head，而 js 文件添加在 body 尾部？
答案：因为 head 中的资源会在浏览器解析 body 之前加载并执行完毕。样式表需要在 body 解析前生效，否则用户有可能看到一闪而过的样式崩坏的页面。js 逻辑一般在类似 `DOMContentLoaded` 的事件回调中执行，所以在很多情况下，并不需要把 js 文件放置在 head 头部。因为在浏览器加载 head 中引用的资源时，页面会处于完全空白的状态。放在 body 尾部的原因是，浏览器在解析 body 期间，遇到 js 文件会先等待 js 文件加载执行完毕，然后再解析剩余部分。放置在 body 尾部，可以让页面更快呈现出来，带来更好的用户体验。
2. script 标签上的 defer 和 async 有什么用？浏览器下载脚本资源时不阻塞 dom 的后续渲染。defer 会在 body 全部渲染完毕后执行，async 会在资源下载完成时，停止 dom 渲染并立即执行脚本内容，然后继续渲染 dom


### 浏览器渲染相关
关键过程如下：
- 解析HTML，生成DOM树(DOM)
- 解析CSS，生成CSSOM树
- 将DOM和CSSOM合并，生成渲染树（Rendere-Tree）
- 计算渲染树的布局Layout
- 将布局渲染到屏幕上Paint

Q: 为什么要构建DOM树？
A: 因为浏览器不能直接理解和使用HTML，需要将HTML转换为浏览器能够理解的结构，这就是DOM树。

Q: CSS加载会阻塞页面展示吗？
A: 不会阻塞DOM树的解析，但是会阻塞DOM树的渲染，并且会阻塞后面的JS执行。

Q: 什么是回流？什么时候触发回流？
A: 通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。

- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 元素字体大小变化
- 激活CSS伪类（例如：:hover）

Q: 重绘和回流的关系？
A: 回流一定重绘，重绘不一定回流。当修改元素的css属性不影响其位置和大小时，不会触发回流，只有重绘。
